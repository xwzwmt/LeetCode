[前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)
{: id="20201105095423-wlnf7do"}

* {: id="20201105095536-b3bdwuc"}优先队列实现最小堆
{: id="20201105095536-3xylqbt"}

1. {: id="20201105095604-qgom05x"}遍历整个数组，存入hashmap中键为值，值为个数
2. {: id="20201105095633-7gifexb"}依次把hash表中的键值存入最小堆。键值存在数组中，数组存入最小堆。规定数组下标为0 存键，下标为1存值
3. {: id="20201105095837-mo8oop9"}当最小堆的size等于k时，以后再入堆时，比较当前值与入堆的值，如果当前值比堆顶值大，则弹出堆顶，并且当前值入堆。
4. {: id="20201105100137-d8cp0y9"}当hashmap遍历结束，堆中就只剩下前k个高频元素了
5. {: id="20201105100212-6pxvhxo"}注意事项（堆中存储特定数据结构，需要重写`Comparator`）
{: id="20201105095604-vzdirt3"}

```
  PriorityQueue<int []> pqueue=new PriorityQueue<>(new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[1]-o2[1];
            }
        });
        int [] results=new int[k];
        Map<Integer,Integer> map=new HashMap<>();
        for(int num:nums){
            int value=map.getOrDefault(num,0);
            map.put(num,++value);
        }
        int count=0;
        for(Integer key:map.keySet()){
            int [] arr=new int[2];
            arr[0]=key;
            arr[1]=map.get(key);
           if(pqueue.size()==k){
               if(pqueue.peek()[1]<arr[1]){
                   pqueue.poll();
                   pqueue.add(arr);
               }
           }else{
               pqueue.add(arr);
           }
        }
        for(int i=0;i<k;i++){
            results[i]=pqueue.poll()[0];
        }
        return results;
```
{: id="20201105100241-7gna439"}

* {: id="20201105132301-ffx7s7r"}桶排序
{: id="20201105132301-p3bnix0"}

1. {: id="20201105132308-xdfpj3o"}遍历数组，将数值做key,数值出现的次数做value，放入hashmap中。
2. {: id="20201105132353-ykp0aap"}创建一个原数组大小的桶，下标就是出现的次数，存放的为list，如果一个桶内有多个元素即可用add
3. {: id="20201105132552-s253342"}切记题意要求高频元素，桶的下标是频次，则倒序遍历数组，如果桶不为空就将整个list加入result的数组中
{: id="20201105132308-0ift2e0"}
