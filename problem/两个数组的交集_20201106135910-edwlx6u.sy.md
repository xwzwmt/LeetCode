[两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)
{: id="20201106135935-qgjg8da"}

* {: id="20201106140025-cozbc49"}排序
{: id="20201106140025-4rvzqp1"}

1. {: id="20201106140032-dg6vwxr"}将两个数组排序
2. {: id="20201106140036-hh1xvj6"}用两个指针标记当前两个数组排到哪个位置
3. {: id="20201106140111-7c9olhy"}拥有更小的那个值的数组的指针往下走，如果两个数组当前值相等，两个指针往下走并且将值入结果数组
{: id="20201106140032-0reg81h"}

时间复杂度：两个数组排序时间复杂度是O(nlogn+mlogm)（n和m是两个数组的长度），遍历两个数组时间为O(m+n)。所以时间复杂度为O（n+m）
{: id="20201106140443-ds4qbsr"}

空间复杂度：需要额外的数组存储O(n)
{: id="20201106140501-euz0aen"}

```
 //num1是最小的
        if(nums1.length>nums2.length){
            return intersect(nums2,nums1);
        }
        int [] results=new int[nums1.length];
        Arrays.sort(nums1);
        Arrays.sort(nums2);
       int p=0,q=0,count=0;
       while (p<nums1.length&&q<nums2.length){
           if(nums1[p]<nums2[q]){
               p++;
           }
           else if(nums1[p]>nums2[q]){
               q++;
           }
           else{
               results[count++]=nums1[p];
               p++;
               q++;
           }
       }
       return Arrays.copyOfRange(results,0,count);
```
{: id="20201106135943-s28571b"}

* {: id="20201106141156-vwn3p0x"}Hash表
{: id="20201106141156-qjz2928"}

时间复杂度：遍历两个数组为O(m+n)，hash表操作为O(1)
{: id="20201106141433-isgbhaq"}

空间复杂度：hash表长度不会超过两个数组中
{: id="20201106141519-s5jsy7a"}

```
HashMap<Integer,Integer> map=new HashMap<>();
       int [] results=new int[nums1.length];
       for(int i=0;i<nums1.length;i++){
           int value=map.getOrDefault(nums1[i],0)+1;
           map.put(nums1[i],value);
       }
       int count=0;
       for(int i=0;i<nums2.length;i++){
           int value=map.getOrDefault(nums2[i],0);
           if(value>0){
               results[count++]=nums2[i];
               value--;
               map.put(nums2[i],value);
           }
       }
       return Arrays.copyOfRange(results,0,count);
```
{: id="20201106141200-f7fxfjv"}
