#### [解码方法](https://leetcode-cn.com/problems/decode-ways/)
{: id="20201225160301-x29ogdu"}

* {: id="20201225160308-5p401c5"}动态规划
{: id="20201225160308-jl4r780"}

分为两种情况：
{: id="20201225160310-jnvacxi"}

① 1~9之间
{: id="20201225160326-0fxawse"}

dp[i]=dp[i-1]
{: id="20201225160534-pp2d8dk"}

②与a[i-1]组成的数字在10~26之间
{: id="20201225160348-kneeua4"}

dp[i]=dp[i-2]
{: id="20201225160545-bac5192"}

注意对i=1的情况单独讨论
{: id="20201225160614-9esc3by"}

时间复杂度：一个for循环 O(n)
{: id="20201225160632-cly963s"}

空间复杂度：额外的数组空间以及常量级变量 O(n)
{: id="20201225160650-a2goiwq"}

```
  //边界条件
        if(s.charAt(0)=='0'){
            return 0;
        }
        int[] dp=new int[s.length()];
        Arrays.fill(dp,0);
        dp[0]=1;
        for(int i=1;i<s.length();i++){
            int ai=Character.getNumericValue(s.charAt(i));
            int a1=Character.getNumericValue(s.charAt(i-1));
            int value=a1*10+ai;

            if(ai>=1&&ai<=9){
                dp[i]+=dp[i-1];
            }
            if(value>=10&&value<=26){
                if(i==1){
                    dp[i]+=1;
                }
                if(i-2>=0){
                    dp[i]+=dp[i-2];
                }
            }
        }
        return dp[s.length()-1];
```
{: id="20201225160554-wru6lho"}

```

 if (s == null || s.length() == 0) {
            return 0;
        }
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = s.charAt(0) != '0' ? 1 : 0;
        for (int i = 2; i <= n; i++) {
            int first = Integer.valueOf(s.substring(i - 1, i));
            int second = Integer.valueOf(s.substring(i - 2, i));
            if (first >= 1 && first <= 9) {
               dp[i] += dp[i-1];  
            }
            if (second >= 10 && second <= 26) {
                dp[i] += dp[i-2];
            }
        }
        return dp[n];
```
{: id="20201225161548-yg4zpp9"}
