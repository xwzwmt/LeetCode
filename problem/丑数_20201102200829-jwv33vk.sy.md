[丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)
{: id="20201103085423-2hpb7hq"}

* {: id="20201103085423-ntdggl8"}数学解法
{: id="20201103085423-hdozwf4"}

1. {: id="20201103085423-up8kbfq"}只有因子2、3、5，那么A0* A1* ....An(A属于丑数)属于丑数，那么A0* A1 * ...An-1也属于丑数
2. {: id="20201103085423-4ycdtex"}大丑数必定是小丑数的n(2/3/5)倍
3. {: id="20201103085423-6hvqcwc"}每次遍历取三个变量中最小的一个存入数组，相应的变量基数++
{: id="20201103085423-5l3ypf6"}

```
 int [] ugly=new int[n];
    ugly[0]=1;
    int a=0;
    int b=0;
    int c=0;
    for(int i=1;i<n;i++){
        int a2=ugly[a]*2;
        int a3=ugly[b]*3;
        int a5=ugly[c]*5;
        ugly[i]=Math.min(a2,Math.min(a3,a5));
        if(a2==ugly[i]) a++;
        if(a3==ugly[i]) b++;
        if(a5==ugly[i]) c++;
    }
    return ugly[n-1];
```
{: id="20201103085423-czh3e1i"}

* {: id="20201103085423-2kh32gg"}优先队列
{: id="20201103085423-04h13sp"}

1. {: id="20201103085423-yw9f3lg"}优先队列每次出的数都是最小的
{: id="20201103085423-zechxbe"}

```
 int nums[]=new int[1690];
    public Solution(){
        Set<Long> myset=new HashSet<>();
        PriorityQueue<Long> myqueue=new PriorityQueue<>();
        myqueue.add((long) 1);
        int [] temps={2,3,5};
        long newUgly,currUgly;
        for(int i=0;i<1690;i++){
             currUgly=myqueue.poll();
             nums[i]=(int)currUgly;
            for(int temp:temps){
                newUgly=temp*currUgly;
                if(!myset.contains(newUgly)){
                    myset.add(newUgly);
                    myqueue.add(newUgly);
                }
            }
        }
    }
    public int nthUglyNumber(int n) {
        new Solution();
        return nums[n-1];
    }
```
{: id="20201103160041-wrhtmaw"}
