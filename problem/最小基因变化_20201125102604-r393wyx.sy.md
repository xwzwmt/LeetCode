#### [最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)
{: id="20201126085157-zi3b2vz"}

* {: id="20201126085157-6i2m3x1"}递归的暴力法
{: id="20201126085157-00le0hu"}

```
 int MinChange=Integer.MAX_VALUE;
    public int minMutation(String start, String end, String[] bank) {
        char[][] banks=new char[bank.length][8];
         for(int i=0;i<bank.length;i++){
            banks[i]=bank[i].toCharArray();
        }
        recursion(start.toCharArray(),end.toCharArray(),banks,0);
        return MinChange==Integer.MAX_VALUE?-1:MinChange;
    }
    private void recursion(char[] start,char[] end,char[][] bank,int change){
        if(Arrays.equals(start,end)){
            MinChange=Math.min(MinChange,change);
        }
        for(int i=0;i<bank.length;i++){
            char[] temp=bank[i];
            if(temp==null){
                continue;
            }
            int diff=0;
            for(int j=0;j<start.length;j++){
                if(start[j]!=temp[j]){
                    diff++;
                }
            }
            if(diff==1){
                bank[i]=null;
                recursion(temp,end,bank,change+1);
                bank[i]=temp;
            }
        }
    } static int MinChange=Integer.MAX_VALUE;
    public static int minMutation(String start, String end, String[] bank) {
        char[][] banks=new char[bank.length][8];
        //初始化bank
        for(int i=0;i<bank.length;i++){
            banks[i]=bank[i].toCharArray();
        }
        //转换为char数组为了好比较
        recursion(start.toCharArray(),end.toCharArray(),banks,0);
        return MinChange==Integer.MAX_VALUE?-1:MinChange;
    }
    private static void recursion(char[] start,char[] end,char[][] bank,int change){
        //递归出口，如果start已经和end相等
        if(Arrays.equals(start,end)){
            MinChange=Math.min(MinChange,change);
        }
        //比较bank中的每一个序列
        for(int i=0;i<bank.length;i++){
            char[] temp=bank[i];
            if(temp==null){
                continue;
            }
            int diff=0;
            //基因库中的某个基因，的每个元素与start相比
            for(int j=0;j<start.length;j++){
                if(start[j]!=temp[j]){
                    diff++;
                }
            }
            //如果只有一个不一样，就可以作为一个树枝，往下递归
            if(diff==1){
                //已经比对过后的，清空
                bank[i]=null;
                recursion(temp,end,bank,change+1);
                //当前递归结束重置
                bank[i]=temp;
            }
        }
    }
```
{: id="20201126085157-ntmuqax"}
