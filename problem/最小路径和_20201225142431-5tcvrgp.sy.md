#### [最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
{: id="20201225142438-9bxybdd"}

* {: id="20201225142455-gca6hqz"}动态规划
{: id="20201225142455-e99llmw"}

dp[i][j]=min{dp[i+1][j],dp[i][j+1]}+a[i][j]
{: id="20201225142457-cujjjyv"}

注意最下面一行和最右边的列初始化为dp[i][j]+=dp[i][j+1] | dp[i][j]+=dp[i+1][j]
{: id="20201225142554-za2m4en"}

时间复杂度：两层for循环 O(n2)
{: id="20201225143025-f5fxorn"}

空间复杂度：没有额外开数组，只有局部变量
{: id="20201225143042-eutbve9"}

```
//边界条件
        if(grid==null||grid.length==0||grid[0].length==0){
            return 0;
        }
        int m=grid.length;
        int n=grid[0].length;
        //最右边的列初始化
        for(int j=n-2;j>=0;j--){
            grid[m-1][j]+=grid[m-1][j+1];
        }
        //最下面的行初始化
        for(int i=m-2;i>=0;i--){
            grid[i][n-1]+=grid[i+1][n-1];
        }
        for(int i=grid.length-2;i>=0;i--){
            for(int j=grid[i].length-2;j>=0;j--){
                grid[i][j]+=Math.min(grid[i+1][j],grid[i][j+1]);
            }
        }
        return grid[0][0];
```
{: id="20201225142743-461pq45"}

{: id="20201225143115-dncs9ta"}
