[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)
{: id="20201105143116-uoyy00e"}

* {: id="20201105143138-6r4gf7n"}非常好理解的方法（分层）
{: id="20201105143206-ng3az5q"}

1. {: id="20201105144835-pwqcbqc"}以矩形的最高高度来进行分层
2. {: id="20201105144856-hzxgwdj"}每一层只要小于当前层次数，就可以++
{: id="20201105144835-rb5ubv2"}

时间复杂度：两个for循环O(n2)
{: id="20201105153351-0ljhaqi"}

```
 int MaxHeight=0;
        for(int h:height){
            if(h>MaxHeight){
                MaxHeight=h;
            }
        }
        int water=0;
        for(int i=1;i<=MaxHeight;i++){
            boolean myswitch=false;
            //用temp来记录当前成水量，
            int temp=0;
            for(int j=0;j<height.length;j++){
                //高于当前层了，说明temp中的水有右边界了，所以直接加到结果里
                if(height[j]>=i){
                    water+=temp;
                    myswitch=true;
                    temp=0;
                }
                //低于当前层temp++
                if(height[j]<i&&myswitch){
                    temp++;
                }
            }
        }
        return water;
```
{: id="20201105144921-2slgpjx"}

* {: id="20201105145653-mfvnxwu"}分列
{: id="20201105145653-nc5439g"}

1. {: id="20201105145714-1m8zzth"}找出当前列，左边最高
2. {: id="20201105145723-elxqh0r"}找出当前列右边最高
3. {: id="20201105145737-9k3hr5m"}只要当前列比最左边最高和右边最高小，就一定能盛水
{: id="20201105145714-e9xj64s"}

时间复杂度：两个嵌套for循环O(n2)
{: id="20201105153415-gyvjvrp"}

```
 int water=0;
        for(int i=1;i<height.length-1;i++){
            int left=height[i-1];
            int right=height[i+1];
            for(int j=i-1;j>=0;j--){
                if(height[j]>left){
                    left=height[j];
                }
            }
            for (int j=i+1;j<height.length;j++){
                if(height[j]>right){
                    right=height[j];
                }
            }
            if(height[i]<Integer.min(left,right)){
                water+=Integer.min(left,right)-height[i];
            }
        }
        return water;
```
{: id="20201105153309-2sw4j1s"}
